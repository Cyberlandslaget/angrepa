use axum::{
    body::Bytes,
    extract::Path,
    http::StatusCode,
    routing::{get, post},
    Json, Router,
};
use axum_typed_multipart::{FieldData, TryFromMultipart, TypedMultipart};
use serde_json::{json, Value};

use angrapa::db::Db;
use angrapa::db_connect;
use angrapa::models::ExploitInserter;

use crate::runner::exploit::exploit2::docker::DockerInstance;

#[derive(TryFromMultipart)]
struct RequestData {
    tar: FieldData<Bytes>,
    config: FieldData<Bytes>,
}

async fn upload(
    TypedMultipart(RequestData { tar, config }): TypedMultipart<RequestData>,
) -> (StatusCode, Json<Value>) {
    let mut db = Db::new(db_connect().unwrap());

    #[derive(serde::Deserialize)]
    struct JsonConfig {
        name: String,
        service: String,
        blacklist: Vec<String>,
    }

    // read data
    let json_config = match serde_json::from_slice(&config.contents) {
        Ok(json_config) => json_config,
        Err(e) => {
            return (
                StatusCode::BAD_REQUEST,
                json!({ "error": "Failed to parse config", "message": format!("{:?}", e) }).into(),
            );
        }
    };

    let JsonConfig {
        name,
        service,
        blacklist,
    } = json_config;

    // build the exploit
    let docker = DockerInstance::new().unwrap();
    let exploit = docker.new_exploit(&tar.contents).await;

    let exploit = match exploit {
        Ok(exploit) => exploit,
        Err(e) => {
            return (
                StatusCode::INTERNAL_SERVER_ERROR,
                json!({ "error": "Failed to build exploit", "message": format!("{:?}", e) }).into(),
            );
        }
    };

    let pool = exploit.spawn_pool().await.unwrap();

    let expl = db
        .add_exploit(&ExploitInserter {
            name,
            service,
            blacklist: blacklist.join("\n"),
            docker_image: pool.image,
            docker_container: pool.container,
            enabled: false,
        })
        .unwrap();

    // save to file
    std::fs::write(
        format!("./data/exploits/{}", expl.id),
        tar.contents.to_owned(),
    )
    .unwrap();

    (StatusCode::OK, json!({ "id": expl.id }).into())
}

pub async fn start(Path(id): Path<i32>) -> (StatusCode, Json<Value>) {
    let mut db = Db::new(db_connect().unwrap());

    db.start_exploit(id).unwrap();

    (StatusCode::OK, json!({ "status": "ok"}).into())
}

pub async fn stop(Path(id): Path<i32>) -> (StatusCode, Json<Value>) {
    let mut db = Db::new(db_connect().unwrap());

    db.stop_exploit(id).unwrap();

    (StatusCode::OK, json!({ "status": "ok"}).into())
}

pub fn router() -> Router {
    Router::new()
        .route("/upload", post(upload))
        .route("/start", get(start).post(start))
        .route("/stop", get(stop).post(stop))
}
