use axum::{
    body::Bytes,
    extract::Path,
    http::StatusCode,
    routing::{get, post},
    Json, Router,
};
use axum_typed_multipart::{FieldData, TryFromMultipart, TypedMultipart};
use serde_json::{json, Value};

use angrapa::db::Db;
use angrapa::db_connect;
use angrapa::models::ExploitInserter;

use crate::runner::exploit::exploit2::docker::DockerInstance;

#[derive(TryFromMultipart)]
struct RequestData {
    tar: FieldData<Bytes>,
    config: FieldData<Bytes>,
}

async fn upload(
    TypedMultipart(RequestData { tar, config }): TypedMultipart<RequestData>,
) -> (StatusCode, Json<Value>) {
    let mut db = Db::new(match db_connect() {
        Ok(db) => db,
        Err(e) => {
            return (
                StatusCode::INTERNAL_SERVER_ERROR,
                json!({ "error": "Failed to connect to database", "message": format!("{:?}", e) })
                    .into(),
            );
        }
    });

    #[derive(serde::Deserialize)]
    struct JsonConfig {
        name: String,
        service: String,
        blacklist: Vec<String>,
    }

    // read data
    let json_config = match serde_json::from_slice(&config.contents) {
        Ok(json_config) => json_config,
        Err(e) => {
            return (
                StatusCode::BAD_REQUEST,
                json!({ "error": "Failed to parse config", "message": format!("{:?}", e) }).into(),
            );
        }
    };

    let JsonConfig {
        name,
        service,
        blacklist,
    } = json_config;

    // build the exploit
    let docker = match DockerInstance::new() {
        Ok(docker) => docker,
        Err(e) => {
            return (
                StatusCode::INTERNAL_SERVER_ERROR,
                json!({ "error": "Failed to connect to docker", "message": format!("{:?}", e) })
                    .into(),
            );
        }
    };

    let exploit = docker.new_exploit(&tar.contents).await;

    let exploit = match exploit {
        Ok(exploit) => exploit,
        Err(e) => {
            return (
                StatusCode::INTERNAL_SERVER_ERROR,
                json!({ "error": "Failed to build exploit", "message": format!("{:?}", e) }).into(),
            );
        }
    };

    let pool = match exploit.spawn_pool().await {
        Ok(pool) => pool,
        Err(e) => {
            return (
                StatusCode::INTERNAL_SERVER_ERROR,
                json!({ "error": "Failed to spawn exploit", "message": format!("{:?}", e) }).into(),
            );
        }
    };

    let expl = match db.add_exploit(&ExploitInserter {
        name,
        service,
        blacklist: blacklist.join("\n"),
        docker_image: pool.image,
        docker_container: pool.container,
        enabled: false,
    }) {
        Ok(expl) => expl,
        Err(e) => {
            return (
                StatusCode::INTERNAL_SERVER_ERROR,
                json!({ "error": "Failed to add exploit to DB", "message": format!("{:?}", e) })
                    .into(),
            );
        }
    };

    // save to file
    if let Err(e) = std::fs::write(
        format!("./data/exploits/{}", expl.id),
        tar.contents.to_owned(),
    ) {
        return (
            StatusCode::INTERNAL_SERVER_ERROR,
            json!({ "error": "Failed to save exploit", "message": format!("{:?}", e) }).into(),
        );
    }

    (StatusCode::OK, json!({ "id": expl.id }).into())
}

pub async fn start(Path(id): Path<i32>) -> (StatusCode, Json<Value>) {
    let mut db = Db::new(match db_connect() {
        Ok(db) => db,
        Err(e) => {
            return (
                StatusCode::INTERNAL_SERVER_ERROR,
                json!({ "error": "Failed to connect to database", "message": format!("{:?}", e) })
                    .into(),
            );
        }
    });

    match db.start_exploit(id) {
        Ok(_) => (StatusCode::OK, json!({ "status": "ok"}).into()),
        Err(e) => (
            StatusCode::INTERNAL_SERVER_ERROR,
            json!({ "error": "Failed to start exploit", "message": format!("{:?}", e) }).into(),
        ),
    }
}

pub async fn stop(Path(id): Path<i32>) -> (StatusCode, Json<Value>) {
    let mut db = Db::new(match db_connect() {
        Ok(db) => db,
        Err(e) => {
            return (
                StatusCode::INTERNAL_SERVER_ERROR,
                json!({ "error": "Failed to connect to database", "message": format!("{:?}", e) })
                    .into(),
            );
        }
    });

    match db.stop_exploit(id) {
        Ok(_) => (StatusCode::OK, json!({ "status": "ok"}).into()),
        Err(e) => (
            StatusCode::INTERNAL_SERVER_ERROR,
            json!({ "error": "Failed to stop exploit", "message": format!("{:?}", e) }).into(),
        ),
    }
}

pub fn router() -> Router {
    Router::new()
        .route("/upload", post(upload))
        .route("/start", get(start).post(start))
        .route("/stop", get(stop).post(stop))
}
