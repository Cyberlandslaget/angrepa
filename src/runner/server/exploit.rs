use axum::{
    body::Bytes,
    extract::Path,
    http::StatusCode,
    routing::{get, post},
    Json, Router,
};
use axum_typed_multipart::{FieldData, TryFromMultipart, TypedMultipart};
use serde_json::{json, Value};

use angrepa::db::Db;
use angrepa::db_connect;
use angrepa::models::ExploitInserter;

use crate::runner::exploit::exploit2::docker::DockerInstance;

#[derive(TryFromMultipart)]
struct RequestData {
    tar: FieldData<Bytes>,
    config: FieldData<Bytes>,
}

// POST /exploit/upload
async fn upload(
    TypedMultipart(RequestData { tar, config }): TypedMultipart<RequestData>,
) -> (StatusCode, Json<Value>) {
    let mut db = Db::new(match db_connect() {
        Ok(db) => db,
        Err(e) => {
            return (
                StatusCode::INTERNAL_SERVER_ERROR,
                json!({ "status": "error", "message": format!("Failed to connect to database: {:?}", e) })
                    .into(),
            );
        }
    });

    #[derive(serde::Deserialize)]
    struct JsonConfig {
        name: String,
        service: String,
        blacklist: Vec<String>,
    }

    // read data
    let json_config = match serde_json::from_slice(&config.contents) {
        Ok(json_config) => json_config,
        Err(e) => {
            return (
                StatusCode::BAD_REQUEST,
                json!({ "status": "error", "message": format!("Failed to parse config: {:?}", e) })
                    .into(),
            );
        }
    };

    let JsonConfig {
        name,
        service,
        blacklist,
    } = json_config;

    // build the exploit
    let docker = match DockerInstance::new() {
        Ok(docker) => docker,
        Err(e) => {
            return (
                StatusCode::INTERNAL_SERVER_ERROR,
                json!({ "status": "error", "message": format!("Failed to connect to docker: {:?}", e) })
                    .into(),
            );
        }
    };

    let exploit = docker.new_exploit(&tar.contents).await;

    let exploit = match exploit {
        Ok(exploit) => exploit,
        Err(e) => {
            return (
                StatusCode::INTERNAL_SERVER_ERROR,
                json!({ "status": "error", "message": format!("Failed to build exploit: {:?}", e) })
                    .into(),
            );
        }
    };

    let pool = match exploit.spawn().await {
        Ok(pool) => pool,
        Err(e) => {
            return (
                StatusCode::INTERNAL_SERVER_ERROR,
                json!({ "status": "error", "message": format!("Failed to spawn exploit: {:?}", e) })
                    .into(),
            );
        }
    };

    let expl = match db.add_exploit(&ExploitInserter {
        name,
        service,
        blacklist: blacklist.join("\n"),
        docker_image: pool.image,
        docker_container: pool.container,
        enabled: false,
    }) {
        Ok(expl) => expl,
        Err(e) => {
            return (
                StatusCode::INTERNAL_SERVER_ERROR,
                json!({ "status": "error", "message": format!("Failed to add exploit to DB: {:?}", e) })
                    .into(),
            );
        }
    };

    // save to file
    if let Err(e) = std::fs::write(format!("./data/exploits/{}", expl.id), &tar.contents) {
        return (
            StatusCode::INTERNAL_SERVER_ERROR,
            json!({ "status": "error", "message": format!("Failed to save exploit: {:?}", e) })
                .into(),
        );
    }

    (
        StatusCode::OK,
        json!({ "status": "ok", "id": expl.id }).into(),
    )
}

// GET|POST /exploit/start/:id
async fn start(Path(id): Path<i32>) -> (StatusCode, Json<Value>) {
    let mut db = Db::new(match db_connect() {
        Ok(db) => db,
        Err(e) => {
            return (
                StatusCode::INTERNAL_SERVER_ERROR,
                json!({ "status": "error", "message": format!("Failed to connect to database: {:?}", e) })
                    .into(),
            );
        }
    });

    match db.start_exploit(id) {
        Ok(_) => (StatusCode::OK, json!({ "status": "ok"}).into()),
        Err(e) => (
            StatusCode::INTERNAL_SERVER_ERROR,
            json!({ "status": "error", "message": format!("Failed to start exploit: {:?}", e) })
                .into(),
        ),
    }
}

// GET|POST /exploit/stop/:id
async fn stop(Path(id): Path<i32>) -> (StatusCode, Json<Value>) {
    let mut db = Db::new(match db_connect() {
        Ok(db) => db,
        Err(e) => {
            return (
                StatusCode::INTERNAL_SERVER_ERROR,
                json!({ "status": "error", "message": format!("Failed to connect to database: {:?}", e) })
                    .into(),
            );
        }
    });

    match db.stop_exploit(id) {
        Ok(_) => (StatusCode::OK, json!({ "status": "ok"}).into()),
        Err(e) => (
            StatusCode::INTERNAL_SERVER_ERROR,
            json!({ "status": "error", "message": format!("Failed to stop exploit: {:?}", e) })
                .into(),
        ),
    }
}

// /exploit/
pub fn router() -> Router {
    Router::new()
        .route("/upload", post(upload))
        .route("/start/:id", get(start).post(start))
        .route("/stop/:id", get(stop).post(stop))
}
