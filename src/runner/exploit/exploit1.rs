use colored::Colorize;
use lazy_static::lazy_static;
use regex::Regex;
use std::time::Duration;

mod docker;

use futures::StreamExt;
use shiplift::{tty::TtyChunk, Docker, ExecContainerOptions};

const FLAG_REGEX_STR: &str = r"ECSC_[A-Za-z0-9\\+/]{32}";
const TICK_TIME: Duration = Duration::from_secs(6);
lazy_static! {
    static ref FLAG_REGEX: Regex = Regex::new(FLAG_REGEX_STR).unwrap();
}

#[derive(Clone)]
pub enum DockerErrors {
    Build(String),
    ContainerCreate(String),
    ContainerKill(String),
    ContainerStart(String),
    ExecuteError(String),
    InvalidArg(String),
    OutputParse(String),
}

pub struct OutputStd {
    stdout: String,
    stderr: String,
}

impl OutputStd {
    /// Function to extract all flags from stdout and stderr
    ///
    /// # Example
    /// ```
    /// println!("{}", output.flags().join("\n"));
    /// ```
    pub fn flags(&self) -> Vec<String> {
        let mut flags: Vec<String> = vec![];

        for cap in FLAG_REGEX.captures_iter(&self.stdout) {
            flags.push(cap[0].to_string());
        }

        for cap in FLAG_REGEX.captures_iter(&self.stderr) {
            flags.push(cap[0].to_string());
        }

        flags
    }
}

impl std::fmt::Display for OutputStd {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "Stdout: {}\nStderr: {}", self.stdout, self.stderr.red())
    }
}

pub fn handle_docker_errors(e: DockerErrors) {
    match e {
        DockerErrors::Build(e) => {
            println!("{} {}", "Image build error:".red().bold(), e.red())
        }
        DockerErrors::ContainerCreate(e) => {
            println!("{} {}", "Container create error:".red().bold(), e.red())
        }
        DockerErrors::ContainerKill(e) => {
            println!("{} {}", "Container kill error:".red().bold(), e.red())
        }
        DockerErrors::ContainerStart(e) => {
            println!("{} {}", "Container start error:".red().bold(), e.red())
        }
        DockerErrors::ExecuteError(e) => {
            println!("{} {}", "Container execute error:".red().bold(), e.red())
        }
        DockerErrors::InvalidArg(e) => {
            println!("{} {}", "Invalid argument error:".red().bold(), e.red())
        }
        DockerErrors::OutputParse(e) => {
            println!("{} {}", "Stdout/err parse error:".red().bold(), e.red())
        }
    }
}

pub async fn attack_example(container_count: u8) {
    let exp = match Exploit::init("test", container_count).await {
        Ok(exp) => exp,
        Err(e) => return handle_docker_errors(e),
    };

    // simulate attacking 100 ips
    let ips = (0..100)
        .collect::<Vec<u16>>()
        .iter()
        .map(|i| format!("172.17.0.{i}"))
        .collect::<Vec<String>>();

    // run the attack
    match exp.tick_attack(ips, "flagid_rfre".to_string()).await {
        Ok(_) => (),
        Err(e) => handle_docker_errors(e),
    }
}

pub struct Exploit {
    name: String,
    tag: String,
    pub containerpool: ContainerPool,
    // pub containers: Vec<Container>,
}

// pub struct Execution {
//     exploit: Exploit,
//     output: OutputStd,
//     flags: Vec<String>,
// }

#[derive(Debug, Clone)]
pub struct Container {
    id: String,
}

#[derive(Debug)]
pub struct ContainerPool {
    exploit_tag: String,
    pub containers: Vec<Container>,
    pub size: u8,
}

trait VecBuffBytes {
    fn to_string(self) -> Result<String, String>;
}

impl VecBuffBytes for Vec<Vec<u8>> {
    /// Flattens a `Vec<Vec<u8>>` and converts to a String
    ///
    /// # Example
    /// ```
    /// let stdout = match stdout_vec.to_string() {
    ///     Ok(stdout) => stdout,
    ///     Err(e) => return Err(e),
    /// };
    /// ```
    fn to_string(self) -> Result<String, String> {
        use std::str::from_utf8;

        let flat = self.into_iter().flatten().collect::<Vec<u8>>();

        match from_utf8(&flat) {
            Ok(s) => Ok(s.to_owned()),
            Err(e) => Err(format!("{:?}", e)),
        }
    }
}

impl Container {
    /// Creates a docker container, returns a Container struct on success
    ///
    /// `tag: &String` tag of the docker image
    ///
    /// # Example
    /// ```
    /// let mut container = match Container::create(&tag).await {
    ///     Ok(container) => container,
    ///     Err(e) => return Err(e),
    /// };
    /// ```
    async fn create(tag: &String) -> Result<Container, DockerErrors> {
        let info = match docker::container_create(tag).await {
            Ok(info) => info,
            Err(e) => return Err(e),
        };

        Ok(Container { id: info.id })
    }

    /// Starts a docker container, returns empty Result on success
    ///
    /// # Example
    /// ```
    /// match container.start().await {
    ///     Ok(_) => (),
    ///     Err(e) => return Err(e),
    /// };
    /// ```
    async fn start(&mut self) -> Result<(), DockerErrors> {
        let docker = Docker::new();
        match docker.containers().get(&self.id).start().await {
            Ok(_) => Ok(()),
            Err(e) => Err(DockerErrors::ContainerStart(format!(
                "Failed to start container with id: \"{}\"\n\t{:?}",
                &self.id[..12],
                e
            ))),
        }
    }

    /// Tries to stop a docker container after a duration
    ///
    /// `duration: Duration` duration to wait before stopping the container
    ///
    /// # Example
    /// ```
    /// match container.stop().await {
    ///     Ok(_) => (),
    ///     Err(e) => return Err(e),
    /// };
    /// ```
    async fn stop(&mut self, duration: Duration) {
        let docker = Docker::new();

        match docker.containers().get(&self.id).stop(Some(duration)).await {
            Ok(_) => (),
            Err(e) => println!(
                "Failed to stop container with id: \"{}\"\n\t{:?}",
                &self.id[..12],
                e
            ),
        };
    }

    /// Runs the exploit on a container, returns the output of the exploit
    ///
    /// `ip: String` ip of the team to attack. Passed to the exploit as an env variable
    ///
    /// `flag_store: String` flag store string. Passed to the exploit as an env variable
    ///
    /// # Example
    /// ```
    /// let output = match container.run(ip.to_string(), &flag_store).await {
    ///     Ok(output) => output,
    ///     Err(e) => return handle_docker_errors(e),
    /// };
    /// ```
    pub async fn run(&self, ip: String, flag_store: &String) -> Result<OutputStd, DockerErrors> {
        // Initalize vector of env vars that are Passed to the exploit
        let ip_env = format!("IP={ip}");
        let flag_store_env = format!("FLAG_STORE={flag_store}");
        let environment_vec = vec![ip_env.as_str(), flag_store_env.as_str()];

        // Initalize exec builder with entrypoint and env args, then later exec
        let docker = Docker::new();
        let options = ExecContainerOptions::builder()
            .cmd(vec!["/exploit/run.sh"])
            .env(environment_vec)
            .attach_stdout(true)
            .attach_stderr(true)
            .build();
        let mut execd = docker.containers().get(&self.id).exec(&options);

        let mut stdout_vec: Vec<Vec<u8>> = vec![];
        let mut stderr_vec: Vec<Vec<u8>> = vec![];

        // Read the chunked output and store in vectors
        while let Some(exec_result) = execd.next().await {
            match exec_result {
                Ok(chunk) => match chunk {
                    TtyChunk::StdOut(bytes) => stdout_vec.push(bytes),
                    TtyChunk::StdErr(bytes) => stderr_vec.push(bytes),
                    TtyChunk::StdIn(_) => unreachable!(),
                },
                Err(e) => {
                    return Err(DockerErrors::ExecuteError(format!(
                        "Failed to execute container with id \"{}\"\n\t{:?}",
                        &self.id[..12],
                        e
                    )))
                }
            }
        }

        // "Dechunk" the data and convert to strings
        let stdout = match stdout_vec.to_string() {
            Ok(stdout) => stdout,
            Err(e) => {
                return Err(DockerErrors::OutputParse(format!(
                    "Failed to convert utf_8 of container exec with id \"{}\"\n\t{e}",
                    &self.id[..12],
                )))
            }
        };

        let stderr = match stderr_vec.to_string() {
            Ok(stderr) => stderr,
            Err(e) => {
                return Err(DockerErrors::OutputParse(format!(
                    "Failed to convert utf_8 of container exec with id \"{}\"\n\t{e}",
                    &self.id[..12],
                )))
            }
        };

        Ok(OutputStd { stdout, stderr })
    }
}

impl ContainerPool {
    /// Creates a new ContainerPool, owned by an Exploit
    ///
    /// `exploit_tag: &String` docker tag of exploit
    ///
    /// `size: u8` number of containers in pool
    ///
    /// # Example
    /// ```
    /// let containerpool = match ContainerPool::new(&tag, container_count).await {
    ///     Ok(containerpool) => containerpool,
    ///     Err(e) => return Err(e),
    /// };
    /// ```
    async fn new(exploit_tag: &String, size: u8) -> Result<ContainerPool, DockerErrors> {
        let mut containers: Vec<Container> = vec![];

        for _ in 0..size {
            let mut container = match Container::create(exploit_tag).await {
                Ok(container) => container,
                Err(e) => return Err(e),
            };

            match container.start().await {
                Ok(_) => (),
                Err(e) => return Err(e),
            };

            containers.push(container);
        }

        Ok(ContainerPool {
            exploit_tag: exploit_tag.clone(),
            containers,
            size,
        })
    }

    /// Adds `count` new containers to the pool, and starts them
    ///
    /// `count: u8` number of containers to add
    ///
    /// # Example
    /// ```
    /// match exp.containerpool.allocate(1).await {
    ///     Ok(_) => (),
    ///     Err(e) => return handle_docker_errors(e),
    /// }
    /// ```
    pub async fn allocate(&mut self, count: u8) -> Result<(), DockerErrors> {
        for _ in 0..count {
            let mut container = match Container::create(&self.exploit_tag).await {
                Ok(container) => container,
                Err(e) => return Err(e),
            };

            match container.start().await {
                Ok(_) => (),
                Err(e) => return Err(e),
            };

            self.containers.push(container);
        }

        Ok(())
    }

    /// Removes `count` amount of containers from pool,
    ///
    /// stops them after 1.5x the tick time to ensure that all exploits finish
    ///
    /// `count: u8` number of containers to remove
    ///
    /// # Example
    /// ```
    /// exp.containerpool.deallocate(1).await?;
    /// ```
    pub async fn deallocate(&mut self, count: u8) -> Result<(), DockerErrors> {
        if count > self.containers.len() as u8 {
            return Err(DockerErrors::InvalidArg(String::from(
                "Can't deallocate more containers than exist in pool",
            )));
        }

        for _ in 0..count {
            let mut container = match self.containers.pop() {
                Some(container) => container,
                None => {
                    return Err(DockerErrors::InvalidArg(String::from(
                        "Can't deallocate more containers than exist in pool",
                    )))
                }
            };

            tokio::task::spawn(async move { container.stop(TICK_TIME + TICK_TIME / 2).await });
        }

        Ok(())
    }
}

impl Exploit {
    /// Creates a new exploit
    ///
    /// `name: &str` name of the exploit (must match name of directory in data/exploits)
    ///
    /// `container_count: u8` number of containers to create
    ///
    /// `start_containers: bool` whether or not to start the containers
    ///
    /// # Example
    /// ```
    /// let exp = match Exploit::init("exploit_name", 1, true).await {
    ///     Ok(exp) => exp,
    ///     Err(e) => return Err(e),
    /// };
    /// ```
    pub async fn init(name: &str, container_count: u8) -> Result<Exploit, DockerErrors> {
        let tag = match docker::image_build(name).await {
            Ok(tag) => tag,
            Err(e) => return Err(e),
        };

        let containerpool = match ContainerPool::new(&tag, container_count).await {
            Ok(containerpool) => containerpool,
            Err(e) => return Err(e),
        };

        Ok(Exploit {
            name: name.to_string(),
            tag,
            containerpool,
        })
    }

    /// Run an attack (must be called every tick) and passes flags to submitter
    ///
    /// Automatically uses all available containers. Spreads the workload evenly
    ///
    /// `ips: Vec<String>` list of ips to attack
    ///
    /// `flag_store: String` flag_store (empty string if none)
    ///
    /// # Example
    ///
    /// ```
    /// match exp.tick_attack(ips, &flag_store).await {
    ///     Ok(_) => (),
    ///     Err(e) => return handle_docker_errors(e),
    /// }
    /// ```
    pub async fn tick_attack(
        self,
        ips: Vec<String>,
        flag_store: String,
    ) -> Result<(), DockerErrors> {
        let mut tasks = Vec::new();
        let pool_size = self.containerpool.size as usize;

        // Split the workload over the available containers
        for t in 0..pool_size {
            let start = t * ips.len() / pool_size;
            let end: usize = (t + 1) * ips.len() / pool_size;

            let task_ips = ips[start..end].to_vec();

            task_ips.iter().for_each(|ip| {
                let container = self.containerpool.containers[t].clone();
                let ip = ip.clone();
                let flag_store = flag_store.clone();

                tasks.push(tokio::spawn(async move {
                    let output = match container.run(ip, &flag_store).await {
                        Ok(output) => output,
                        Err(e) => return Err(e),
                    };

                    Ok(output.flags())
                }));
            });
        }

        futures::future::join_all(tasks)
            .await
            .iter()
            .for_each(|o| match o.as_ref() {
                Ok(flags_res) => match flags_res {
                    Ok(flags) => println!("{}", flags.join("\n")), // TODO: send to flag submitter
                    Err(e) => handle_docker_errors(e.clone()),
                },
                Err(e) => println!("Join error:\n\t{:?}", e),
            });

        Ok(())
    }
}
