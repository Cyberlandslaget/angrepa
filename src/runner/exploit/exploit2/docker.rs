use angrepa::models::ExploitModel;
use async_trait::async_trait;
use bollard::{
    container::{Config, CreateContainerOptions},
    exec::{CreateExecOptions, StartExecOptions, StartExecResults},
    image::BuildImageOptions,
    service::BuildInfo,
    Docker,
};
use futures::StreamExt;
use rand::RngCore;
use thiserror::Error;
use tracing::{debug, warn};

use super::{Exploit, RunLog};

#[derive(Error, Debug)]
pub enum DockerError {
    #[error("bollard error")]
    BollardError(#[from] bollard::errors::Error),
    #[error("dockerfile missing cmd")]
    NoCmd,
}

#[derive(Debug, Clone)]
pub struct BuiltExploit {
    pub docker: Docker,
    pub image: String,
}

#[derive(Debug, Clone)]
/// Has a specific container (i.e. it's "started")
pub struct InitalizedExploit {
    pub docker: Docker,
    pub image: String,
    pub container: String,
    pub cmd: Vec<String>,
}

impl InitalizedExploit {
    pub async fn from_model(docker: Docker, model: ExploitModel) -> Result<Self, DockerError> {
        let image = model.docker_image;
        let container = model.docker_container;

        // TODO check container is running, otherwise spawn new from image

        let cmd = {
            let inspected = docker.inspect_image(&image).await?;

            inspected
                .config
                .ok_or(DockerError::NoCmd)?
                .cmd
                .ok_or(DockerError::NoCmd)?
        };

        Ok(Self {
            docker,
            image,
            container,
            cmd,
        })
    }
}

impl BuiltExploit {
    /// Starts an instance
    pub async fn spawn(&self) -> Result<InitalizedExploit, DockerError> {
        let name = format!(
            "instance_pool_{image}_{random}",
            image = self.image,
            random = rand::random::<u32>()
        );

        // first get the cmd
        let inspected = self.docker.inspect_image(&self.image).await?;

        let cmd = inspected
            .config
            .ok_or(DockerError::NoCmd)?
            .cmd
            .ok_or(DockerError::NoCmd)?;

        // override the entrypoint (cmd)
        let config = Config {
            image: Some(self.image.as_str()),
            cmd: Some(vec!["sleep", "infinity"]),
            tty: Some(true),
            ..Default::default()
        };

        let options = CreateContainerOptions {
            name: name.clone(),
            ..Default::default()
        };

        let container = self.docker.create_container(Some(options), config).await?;

        self.docker
            .start_container::<String>(&container.id, None)
            .await?;

        Ok(InitalizedExploit {
            docker: self.docker.clone(),
            image: self.image.clone(),
            container: container.id,
            cmd,
        })
    }
}

#[async_trait]
impl Exploit for InitalizedExploit {
    type Error = DockerError;

    async fn run_till_completion(
        &self,
        host: String,
        flagid: String,
    ) -> Result<RunLog, DockerError> {
        // the original command
        let cmd = Some(self.cmd.clone());
        let env = Some(vec![format!("IP={host}"), format!("FLAG_ID={flagid}")]);

        let create_options = CreateExecOptions {
            cmd,
            env,
            attach_stdout: Some(true),
            attach_stderr: Some(true), // not sure how to read this
            attach_stdin: Some(false),
            ..Default::default()
        };

        let exec = self
            .docker
            .create_exec(&self.container, create_options)
            .await?;

        let start_options = StartExecOptions {
            detach: false,                      // get output
            output_capacity: Some(1024 * 1024), // should be about 128 thousand chars ???
        };

        let start = self
            .docker
            .start_exec(&exec.id, Some(start_options))
            .await?;

        let (mut output, _input) = match start {
            StartExecResults::Attached { output, input } => (output, input),
            StartExecResults::Detached => unreachable!(),
        };

        // get output
        let mut txt = String::new();

        while let Some(msg) = output.next().await {
            let msg = msg?;
            let msg = msg.to_string();
            txt += &msg;
        }

        Ok(RunLog { output: txt })
    }
}

pub struct DockerInstance {
    docker: Docker,
}

impl DockerInstance {
    pub fn new() -> Result<Self, DockerError> {
        Ok(Self {
            docker: Docker::connect_with_local_defaults()?,
        })
    }

    pub async fn new_exploit(&self, tar: &[u8]) -> Result<BuiltExploit, DockerError> {
        let image_name = {
            let mut bytes = [0u8; 8];
            rand::thread_rng().fill_bytes(&mut bytes);
            format!("exploit_{hash}", hash = hex::encode(bytes))
        };

        debug!("Building new exploit, named '{}'", image_name);

        let options = BuildImageOptions {
            t: image_name.clone(),
            networkmode: String::from("host"),
            memory: Some(1024 * 1024 * 1024 * 8),
            ..Default::default()
        };

        let mut stream = self
            .docker
            .build_image(options, None, Some(tar.to_owned().into()));

        while let Some(msg) = stream.next().await {
            match msg {
                Ok(msg) => {
                    // progress message only has a stream field
                    let progress_info = BuildInfo {
                        stream: msg.stream.clone(),
                        ..Default::default()
                    };

                    // so only print the stream if it's a progress message
                    if msg == progress_info {
                        debug!("Progress: {:?}", msg.stream.unwrap_or_default());
                    } else {
                        debug!("Message: {:?}", msg);
                    }
                }
                Err(e) => {
                    warn!("Error: {:?}", e);
                    return Err(e.into());
                }
            }
        }

        Ok(BuiltExploit {
            image: image_name,
            docker: self.docker.clone(),
        })
    }
}

#[cfg(test)]
mod tests {
    use super::DockerInstance;
    use crate::runner::exploit::exploit2::Exploit;
    use color_eyre::eyre::Report;
    use futures::future::join_all;
    use std::time::Instant;
    use tracing_test::traced_test;

    fn make_tar() -> Result<Vec<u8>, Report> {
        let dockerfile = r###"
FROM python
CMD ["python3", "-c", "import os; print(list(os.environ[x] for x in ['IP', 'FLAG_ID']))"]
"###;
        let mut tar = tar::Builder::new(Vec::new());

        let mut header = tar::Header::new_gnu();
        header.set_size(dockerfile.len() as u64);
        header.set_cksum();
        tar.append_data(&mut header, "Dockerfile", dockerfile.as_bytes())?;
        let tar_data = tar.into_inner()?;

        Ok(tar_data)
    }

    #[tokio::test]
    #[traced_test]
    async fn simple_build() -> Result<(), Report> {
        let tar_data = make_tar()?;

        // build it
        let docker = DockerInstance::new()?;
        let exploit = docker.new_exploit(&tar_data).await?;

        let exploit = exploit.spawn().await?;

        // run it
        let logs = exploit
            .run_till_completion("172.0.1.2".to_string(), "flaghint".to_string())
            .await?;

        eprintln!("{}", logs.output);

        Ok(())
    }

    #[tokio::test]
    #[traced_test]
    async fn pool_test() -> Result<(), Report> {
        let tar_data = make_tar()?;

        // build it
        let docker = DockerInstance::new().unwrap();
        let exploit = docker.new_exploit(&tar_data).await.unwrap();

        // spawn pool container
        let pool = exploit.spawn().await?;

        const INSTANCES: usize = 10;

        let t0 = Instant::now();

        let mut handles = Vec::new();

        for i in 0..INSTANCES {
            let pool = pool.clone();
            handles.push(tokio::spawn(async move {
                let logs = pool
                    .run_till_completion(format!("172.0.1.{i}", i = i), "flaghint".to_string())
                    .await
                    .unwrap();

                eprintln!("{}", logs.output);
            }))
        }

        let start_time = t0.elapsed();
        let t0 = Instant::now();

        // join
        join_all(handles).await;

        let join_time = t0.elapsed();

        println!("Started {} containers in {:?}", INSTANCES, start_time);
        println!("Joined {} containers in {:?}", INSTANCES, join_time);

        Ok(())
    }
}
