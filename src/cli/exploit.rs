use crate::{tarify, Args, GenericResponse, Untarrer};
use angrepa::models::ExploitModel;
use argh::FromArgs;
use colored::Colorize;
use reqwest::multipart::{Form, Part};
use serde_json::json;
use std::path::PathBuf;
use tabled::{Table, Tabled};

#[derive(FromArgs, Debug)]
/// manage exploits
#[argh(subcommand, name = "exploit")]
pub struct Exploit {
    #[argh(subcommand)]
    /// what to do
    cmd: ExploitCommand,
}

impl Exploit {
    pub async fn run(&self, args: &super::Args) {
        match &self.cmd {
            ExploitCommand::Upload(x) => x.run(args).await,
            ExploitCommand::Download(x) => x.run(args).await,
            ExploitCommand::Start(x) => x.run(args).await,
            ExploitCommand::Stop(x) => x.run(args).await,
            ExploitCommand::Ls(x) => x.run(args).await,
        }
    }
}

#[derive(FromArgs, Debug)]
#[argh(subcommand)]
/// Exploit commands
pub enum ExploitCommand {
    Upload(Upload),
    Download(Download),
    Start(Start),
    Stop(Stop),
    Ls(Ls),
}

impl Upload {
    async fn run(&self, args: &Args) {
        // make sure all arguments are valid
        std::fs::read_dir(&self.exploit).expect("failed to read exploit directory");
        let name = self.name.as_ref().expect("missing name");
        let service = self.service.as_ref().expect("missing service");
        let blacklist: Vec<_> = self
            .blacklist
            .as_ref()
            .map(|text| text.split(',').map(|ip| ip.trim()).collect())
            .unwrap_or(vec![]);
        let pool = self.pool;

        // build tar
        let tar = tarify(self.exploit.to_str().unwrap()).expect("failed to tar exploit");

        println!("Uploading {}B file", tar.len());

        // upload
        let client = reqwest::Client::new();
        let url = args.host.join("/exploit/upload").unwrap();

        let config = json!({
            "service": service,
            "name": name,
            "blacklist": blacklist,
            "pool": pool,
        });

        let form = Form::new()
            .text("config", config.to_string())
            .part("tar", Part::bytes(tar).file_name("exploit.tar"));

        let resp = client
            .post(url.clone())
            .multipart(form)
            .send()
            .await
            .unwrap();

        #[derive(serde::Deserialize)]
        struct BuildResponse {
            id: i32,
            build_log: String,
        }

        let response = resp.text().await.unwrap();

        let generic: GenericResponse = serde_json::from_str(&response).unwrap();

        if generic.success() {
            let build: BuildResponse = serde_json::from_str(&response).unwrap();
            println!("{}", build.build_log.trim().blue());
            println!("Successfully built exploit {}", build.id);
        } else {
            println!("Failed to build: '{}'", generic.message.unwrap_or_default());
        }
    }
}

impl Download {
    async fn run(&self, args: &Args) {
        // make sure all arguments are valid
        std::fs::read_dir(&self.path).expect("failed to read output directory. does it exist?");
        let dirname = format!("download_{}", self.id);
        let out_dir = self.path.join(dirname);
        if out_dir.exists() {
            println!("Warning: {} already exists!", out_dir.display());
        }
        std::fs::create_dir_all(&out_dir).unwrap();

        // download
        let client = reqwest::Client::new();
        let endpoint = format!("/exploit/download/{}", self.id);
        let url = args.host.join(&endpoint).unwrap();

        let tar = client.get(url).send().await.unwrap().bytes().await.unwrap();

        // untar
        let untarrer = Untarrer { data: tar.into() };
        untarrer.untar(&out_dir).unwrap();
    }
}
#[derive(FromArgs, Debug)]
#[argh(subcommand, name = "upload")]
/// upload an exploit
pub struct Upload {
    #[argh(positional)]
    /// path to the exploit
    exploit: PathBuf,

    #[argh(option)]
    /// name of service
    service: Option<String>,

    #[argh(option)]
    /// name of exploit
    name: Option<String>,

    #[argh(option)]
    /// pool size
    pool: Option<usize>,

    #[argh(option)]
    /// blacklist, ex. "10.0.0.1, 10.0.0.2"
    blacklist: Option<String>,
}

#[derive(FromArgs, Debug)]
#[argh(subcommand, name = "download")]
/// download an exploit
pub struct Download {
    #[argh(positional)]
    /// exploit id
    id: i32,

    #[argh(option)]
    /// directory to place the exploit folder in
    path: PathBuf,
}

#[derive(FromArgs, Debug)]
#[argh(subcommand, name = "start")]
/// start an exploit
pub struct Start {
    #[argh(positional)]
    /// id of exploit
    id: i32,
}

#[derive(FromArgs, Debug)]
#[argh(subcommand, name = "stop")]
/// stop an exploit
pub struct Stop {
    #[argh(positional)]
    /// id of exploit
    id: i32,
}

#[derive(FromArgs, Debug)]
#[argh(subcommand, name = "ls")]
/// list exploits
pub struct Ls {
    /// only show enabled
    #[argh(switch, long = "enabled")]
    only_enabled: bool,
}

impl Start {
    async fn run(&self, args: &Args) {
        let client = reqwest::Client::new();

        let endpoint = format!("/exploit/start/{}", self.id);
        let url = args.host.join(&endpoint).unwrap();

        let resp: GenericResponse = client
            .post(url.clone())
            .send()
            .await
            .unwrap()
            .json()
            .await
            .unwrap();

        if resp.success() {
            println!("Started exploit {}", self.id);
        } else {
            println!(
                "Failed to start exploit {}: {}",
                self.id,
                resp.message.unwrap_or_default()
            );
        }
    }
}

impl Stop {
    async fn run(&self, args: &Args) {
        let client = reqwest::Client::new();

        let endpoint = format!("/exploit/stop/{}", self.id);
        let url = args.host.join(&endpoint).unwrap();

        let resp: GenericResponse = client
            .post(url.clone())
            .send()
            .await
            .unwrap()
            .json()
            .await
            .unwrap();

        if resp.success() {
            println!("Stopped exploit {}", self.id);
        } else {
            println!(
                "Failed to stop exploit {}: {}",
                self.id,
                resp.message.unwrap_or_default()
            );
        }
    }
}

impl Ls {
    async fn run(&self, args: &Args) {
        let client = reqwest::Client::new();

        let endpoint = "/logs/exploits";
        let url = args.host.join(endpoint).unwrap();

        let txt = client
            .get(url.clone())
            .send()
            .await
            .unwrap()
            .text()
            .await
            .unwrap();

        let generic: GenericResponse = serde_json::from_str(&txt).unwrap();

        if generic.success() {
            #[derive(serde::Deserialize, Debug)]
            struct LsResponse {
                data: Vec<ExploitModel>,
            }

            #[derive(Debug, Clone, Tabled)]
            struct ExploitData {
                pub id: i32,
                pub name: String,
                pub service: String,
                pub enabled: bool,
                pub blacklist: String,
                pub pool_size: i32,
            }

            let response: LsResponse = serde_json::from_str(&txt).unwrap();

            let exploits: Vec<_> = response
                .data
                .into_iter()
                .map(|model| ExploitData {
                    id: model.id,
                    name: model.name,
                    service: model.service,
                    enabled: model.enabled,
                    blacklist: model
                        .blacklist
                        .into_iter()
                        .flatten()
                        .collect::<Vec<String>>()
                        .join(", "),
                    pool_size: model.pool_size,
                })
                .filter(|exploit| exploit.enabled || !self.only_enabled)
                .collect();

            let pretty = Table::new(exploits.clone());

            println!("{}", pretty);
        } else {
            println!(
                "Failed to get exploits {}",
                generic.message.unwrap_or_default()
            );
        }
    }
}
