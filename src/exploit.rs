use super::{DockerErrors, OutputStd};
use crate::docker;

use futures::StreamExt;
use shiplift::{tty::TtyChunk, Docker, ExecContainerOptions};

pub struct Exploit {
    name: String,
    tag: String,
    pub containers: Vec<Container>,
}

// pub struct Execution {
//     exploit: Exploit,
//     output: OutputStd,
//     flags: Vec<String>,
// }

pub struct Container {
    id: String,
    running: bool,
}

trait VecBuffBytes {
    fn to_string(self) -> Result<String, String>;
}

impl VecBuffBytes for Vec<Vec<u8>> {
    /// Flattens a `Vec<Vec<u8>>` and converts to a String
    ///
    /// # Example
    /// ```
    /// let stdout = match stdout_vec.to_string() {
    ///     Ok(stdout) => stdout,
    ///     Err(e) => return Err(e),
    /// };
    /// ```
    fn to_string(self) -> Result<String, String> {
        use std::str::from_utf8;

        let flat = self.into_iter().flatten().collect::<Vec<u8>>();

        match from_utf8(&flat) {
            Ok(s) => Ok(s.to_owned()),
            Err(e) => Err(format!("{:?}", e)),
        }
    }
}

impl Container {
    /// Creates a docker container, returns a Container struct on success
    ///
    /// `tag: &String` tag of the docker image
    ///
    /// # Example
    /// ```
    /// let mut container = match Container::create(&tag).await {
    ///     Ok(container) => container,
    ///     Err(e) => return Err(e),
    /// };
    /// ```
    async fn create(tag: &String) -> Result<Container, DockerErrors> {
        let info = match docker::container_create(tag).await {
            Ok(info) => info,
            Err(e) => return Err(e),
        };

        Ok(Container {
            id: info.id,
            running: false,
        })
    }

    /// Starts a docker container, returns empty Result on success
    ///
    /// # Example
    /// ```
    /// match container.start().await {
    ///     Ok(_) => (),
    ///     Err(e) => return Err(e),
    /// };
    /// ```
    pub async fn start(&mut self) -> Result<(), DockerErrors> {
        let docker = Docker::new();
        match docker.containers().get(&self.id).start().await {
            Ok(_) => {
                self.running = true;
                Ok(())
            }
            Err(e) => Err(DockerErrors::ContainerStart(format!(
                "Failed to start container with id: \"{}\"\n\t{:?}",
                self.id, e
            ))),
        }
    }

    /// Stops a docker container, returns empty Result on success
    ///
    /// # Example
    /// ```
    /// match container.stop().await {
    ///     Ok(_) => (),
    ///     Err(e) => return Err(e),
    /// };
    /// ```
    pub async fn stop(&mut self) -> Result<(), DockerErrors> {
        use std::time::Duration;

        let docker = Docker::new();
        match docker
            .containers()
            .get(&self.id)
            .stop(Some(Duration::new(0, 0)))
            .await
        {
            Ok(_) => {
                self.running = false;
                Ok(())
            }
            Err(e) => Err(DockerErrors::ContainerStop(format!(
                "Failed to stop container with id: \"{}\"\n\t{:?}",
                self.id, e
            ))),
        }
    }

    /// Runs the exploit on a container, returns the output of the exploit
    ///
    /// `ip: String` ip of the team to attack. Passed to the exploit as an env variable
    ///
    /// `flag_store: String` flag store string. Passed to the exploit as an env variable
    ///
    /// # Example
    /// ```
    /// let output = match container.run(ip.to_string(), &flag_store).await {
    ///     Ok(output) => output,
    ///     Err(e) => return handle_docker_errors(e),
    /// };
    /// ```
    pub async fn run(&self, ip: String, flag_store: &String) -> Result<OutputStd, DockerErrors> {
        if !self.running {
            return Err(DockerErrors::ContainerNotRunning(format!(
                "Failed to start exploit\n\tContainer with id: \"{}\" is not running",
                &self.id[..12]
            )));
        }

        // Initalize vector of env vars that are Passed to the exploit
        let ip_env = format!("IP={ip}");
        let flag_store_env = format!("FLAG_STORE={flag_store}");
        let environment_vec = vec![ip_env.as_str(), flag_store_env.as_str()];

        // Initalize exec builder with entrypoint and env args, then later exec
        let docker = Docker::new();
        let options = ExecContainerOptions::builder()
            .cmd(vec!["/exploit/run.sh"])
            .env(environment_vec)
            .attach_stdout(true)
            .attach_stderr(true)
            .build();
        let mut execd = docker.containers().get(&self.id).exec(&options);

        let mut stdout_vec: Vec<Vec<u8>> = vec![];
        let mut stderr_vec: Vec<Vec<u8>> = vec![];

        // Read the chunked output and store in vectors
        while let Some(exec_result) = execd.next().await {
            match exec_result {
                Ok(chunk) => match chunk {
                    TtyChunk::StdOut(bytes) => stdout_vec.push(bytes),
                    TtyChunk::StdErr(bytes) => stderr_vec.push(bytes),
                    TtyChunk::StdIn(_) => unreachable!(),
                },
                Err(e) => {
                    return Err(DockerErrors::ExecuteError(format!(
                        "Failed to execute container with id \"{}\"\n\t{:?}",
                        &self.id[..12],
                        e
                    )))
                }
            }
        }

        // "Dechunk" the data and convert to strings
        let stdout = match stdout_vec.to_string() {
            Ok(stdout) => stdout,
            Err(e) => {
                return Err(DockerErrors::OutputParse(format!(
                    "Failed to convert utf_8 of container exec with id \"{}\"\n\t{e}",
                    &self.id[..12],
                )))
            }
        };

        let stderr = match stderr_vec.to_string() {
            Ok(stderr) => stderr,
            Err(e) => {
                return Err(DockerErrors::OutputParse(format!(
                    "Failed to convert utf_8 of container exec with id \"{}\"\n\t{e}",
                    &self.id[..12],
                )))
            }
        };

        Ok(OutputStd { stdout, stderr })
    }
}

impl Exploit {
    /// Creates a new exploit
    ///
    /// `name: &str` name of the exploit (must match name of directory in data/exploits)
    ///
    /// `container_count: u8` number of containers to create
    ///
    /// `start_containers: bool` whether or not to start the containers
    ///
    /// # Example
    /// ```
    /// let exp = match exploit::Exploit::init("exploit_name", 1, true).await {
    ///     Ok(exp) => exp,
    ///     Err(e) => return Err(e),
    /// };
    /// ```
    pub async fn init(
        name: &str,
        container_count: u8,
        start_containers: bool,
    ) -> Result<Exploit, DockerErrors> {
        let tag = match docker::image_build(name).await {
            Ok(tag) => tag,
            Err(e) => return Err(e),
        };

        let mut containers: Vec<Container> = vec![];

        for _ in 0..container_count {
            let mut container = match Container::create(&tag).await {
                Ok(container) => container,
                Err(e) => return Err(e),
            };

            if start_containers {
                match container.start().await {
                    Ok(_) => (),
                    Err(e) => return Err(e),
                };
            }

            containers.push(container);
        }

        Ok(Exploit {
            name: name.to_string(),
            tag,
            containers,
        })
    }

    /// Get indexes of all running containers of the exploit
    ///
    /// # Example
    /// ```
    /// let containers = exp.running_containers();
    /// ```
    pub fn running_containers(&self) -> Vec<u8> {
        let mut running: Vec<u8> = vec![];

        for (x, c) in self.containers.iter().enumerate() {
            if c.running {
                running.push(x as u8);
            }
        }

        running
    }
}
