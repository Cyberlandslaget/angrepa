use super::{handle_docker_errors, DockerErrors, OutputStd};
use crate::docker;

use futures::StreamExt;
use shiplift::{tty::TtyChunk, Docker, ExecContainerOptions};

pub struct Exploit {
    name: String,
    tag: String,
    pub containerpool: ContainerPool,
    // pub containers: Vec<Container>,
}

// pub struct Execution {
//     exploit: Exploit,
//     output: OutputStd,
//     flags: Vec<String>,
// }

#[derive(Clone)]
pub struct Container {
    id: String,
    running: bool,
    active: bool,
}

pub struct ContainerPool {
    exploit_tag: String,
    pub containers: Vec<Container>,
    pub size: u8,
}

trait VecBuffBytes {
    fn to_string(self) -> Result<String, String>;
}

impl VecBuffBytes for Vec<Vec<u8>> {
    /// Flattens a `Vec<Vec<u8>>` and converts to a String
    ///
    /// # Example
    /// ```
    /// let stdout = match stdout_vec.to_string() {
    ///     Ok(stdout) => stdout,
    ///     Err(e) => return Err(e),
    /// };
    /// ```
    fn to_string(self) -> Result<String, String> {
        use std::str::from_utf8;

        let flat = self.into_iter().flatten().collect::<Vec<u8>>();

        match from_utf8(&flat) {
            Ok(s) => Ok(s.to_owned()),
            Err(e) => Err(format!("{:?}", e)),
        }
    }
}

impl Container {
    /// Creates a docker container, returns a Container struct on success
    ///
    /// `tag: &String` tag of the docker image
    ///
    /// # Example
    /// ```
    /// let mut container = match Container::create(&tag).await {
    ///     Ok(container) => container,
    ///     Err(e) => return Err(e),
    /// };
    /// ```
    async fn create(tag: &String) -> Result<Container, DockerErrors> {
        let info = match docker::container_create(tag).await {
            Ok(info) => info,
            Err(e) => return Err(e),
        };

        Ok(Container {
            id: info.id,
            running: false,
            active: false,
        })
    }

    /// Starts a docker container, returns empty Result on success
    ///
    /// # Example
    /// ```
    /// match container.start().await {
    ///     Ok(_) => (),
    ///     Err(e) => return Err(e),
    /// };
    /// ```
    async fn start(&mut self) -> Result<(), DockerErrors> {
        let docker = Docker::new();
        match docker.containers().get(&self.id).start().await {
            Ok(_) => {
                self.running = true;
                self.active = true;
                Ok(())
            }
            Err(e) => Err(DockerErrors::ContainerStart(format!(
                "Failed to start container with id: \"{}\"\n\t{:?}",
                self.id, e
            ))),
        }
    }

    // async fn safe_stop(&mut self) -> Result<(), DockerErrors> {}

    /// Stops a docker container, returns empty Result on success
    ///
    /// # Example
    /// ```
    /// match container.stop().await {
    ///     Ok(_) => (),
    ///     Err(e) => return Err(e),
    /// };
    /// ```
    async fn stop(&mut self) -> Result<(), DockerErrors> {
        use std::time::Duration;

        let docker = Docker::new();
        match docker
            .containers()
            .get(&self.id)
            .stop(Some(Duration::new(0, 0)))
            .await
        {
            Ok(_) => {
                self.running = false;
                Ok(())
            }
            Err(e) => Err(DockerErrors::ContainerStop(format!(
                "Failed to stop container with id: \"{}\"\n\t{:?}",
                self.id, e
            ))),
        }
    }

    /// Runs the exploit on a container, returns the output of the exploit
    ///
    /// `ip: String` ip of the team to attack. Passed to the exploit as an env variable
    ///
    /// `flag_store: String` flag store string. Passed to the exploit as an env variable
    ///
    /// # Example
    /// ```
    /// let output = match container.run(ip.to_string(), &flag_store).await {
    ///     Ok(output) => output,
    ///     Err(e) => return handle_docker_errors(e),
    /// };
    /// ```
    pub async fn run(&self, ip: String, flag_store: &String) -> Result<OutputStd, DockerErrors> {
        if !self.running {
            return Err(DockerErrors::ContainerNotRunning(format!(
                "Failed to start exploit\n\tContainer with id: \"{}\" is not running",
                &self.id[..12]
            )));
        }

        // Initalize vector of env vars that are Passed to the exploit
        let ip_env = format!("IP={ip}");
        let flag_store_env = format!("FLAG_STORE={flag_store}");
        let environment_vec = vec![ip_env.as_str(), flag_store_env.as_str()];

        // Initalize exec builder with entrypoint and env args, then later exec
        let docker = Docker::new();
        let options = ExecContainerOptions::builder()
            .cmd(vec!["/exploit/run.sh"])
            .env(environment_vec)
            .attach_stdout(true)
            .attach_stderr(true)
            .build();
        let mut execd = docker.containers().get(&self.id).exec(&options);

        let mut stdout_vec: Vec<Vec<u8>> = vec![];
        let mut stderr_vec: Vec<Vec<u8>> = vec![];

        // Read the chunked output and store in vectors
        while let Some(exec_result) = execd.next().await {
            match exec_result {
                Ok(chunk) => match chunk {
                    TtyChunk::StdOut(bytes) => stdout_vec.push(bytes),
                    TtyChunk::StdErr(bytes) => stderr_vec.push(bytes),
                    TtyChunk::StdIn(_) => unreachable!(),
                },
                Err(e) => {
                    return Err(DockerErrors::ExecuteError(format!(
                        "Failed to execute container with id \"{}\"\n\t{:?}",
                        &self.id[..12],
                        e
                    )))
                }
            }
        }

        // "Dechunk" the data and convert to strings
        let stdout = match stdout_vec.to_string() {
            Ok(stdout) => stdout,
            Err(e) => {
                return Err(DockerErrors::OutputParse(format!(
                    "Failed to convert utf_8 of container exec with id \"{}\"\n\t{e}",
                    &self.id[..12],
                )))
            }
        };

        let stderr = match stderr_vec.to_string() {
            Ok(stderr) => stderr,
            Err(e) => {
                return Err(DockerErrors::OutputParse(format!(
                    "Failed to convert utf_8 of container exec with id \"{}\"\n\t{e}",
                    &self.id[..12],
                )))
            }
        };

        Ok(OutputStd { stdout, stderr })
    }
}

impl ContainerPool {
    /// Creates a new ContainerPool, owned by an Exploit
    ///
    /// `exploit_tag: &String` docker tag of exploit
    ///
    /// `size: u8` number of containers in pool
    ///
    /// # Example
    /// ```
    /// let containerpool = match ContainerPool::new(&tag, container_count).await {
    ///     Ok(containerpool) => containerpool,
    ///     Err(e) => return Err(e),
    /// };
    /// ```
    async fn new(exploit_tag: &String, size: u8) -> Result<ContainerPool, DockerErrors> {
        let mut containers: Vec<Container> = vec![];

        for _ in 0..size {
            let mut container = match Container::create(exploit_tag).await {
                Ok(container) => container,
                Err(e) => return Err(e),
            };

            match container.start().await {
                Ok(_) => (),
                Err(e) => return Err(e),
            };

            containers.push(container);
        }

        Ok(ContainerPool {
            exploit_tag: exploit_tag.clone(),
            containers,
            size,
        })
    }

    /// Adds a new Container to the pool, and starts it
    ///
    /// `count: u8` number of containers to add
    ///
    /// # Example
    /// ```
    /// match exp.containerpool.allocate(1).await {
    ///     Ok(_) => (),
    ///     Err(e) => return handle_docker_errors(e),
    /// }
    /// ```
    pub async fn allocate(&mut self, count: u8) -> Result<(), DockerErrors> {
        for _ in 0..count {
            let mut container = match Container::create(&self.exploit_tag).await {
                Ok(container) => container,
                Err(e) => return Err(e),
            };

            match container.start().await {
                Ok(_) => (),
                Err(e) => return Err(e),
            };

            self.containers.push(container);
        }

        Ok(())
    }
}

impl Exploit {
    /// Creates a new exploit
    ///
    /// `name: &str` name of the exploit (must match name of directory in data/exploits)
    ///
    /// `container_count: u8` number of containers to create
    ///
    /// `start_containers: bool` whether or not to start the containers
    ///
    /// # Example
    /// ```
    /// let exp = match exploit::Exploit::init("exploit_name", 1, true).await {
    ///     Ok(exp) => exp,
    ///     Err(e) => return Err(e),
    /// };
    /// ```
    pub async fn init(name: &str, container_count: u8) -> Result<Exploit, DockerErrors> {
        let tag = match docker::image_build(name).await {
            Ok(tag) => tag,
            Err(e) => return Err(e),
        };

        let containerpool = match ContainerPool::new(&tag, container_count).await {
            Ok(containerpool) => containerpool,
            Err(e) => return Err(e),
        };

        Ok(Exploit {
            name: name.to_string(),
            tag,
            containerpool,
        })
    }

    /// Run an attack (must be called every tick), submits flags
    ///
    /// Automatically uses all aviailable containers spreads the workload evenly
    ///
    /// `ips: Vec<String>` list of ips to attack
    ///
    /// `flag_store: String` flag_store (empty string if none)
    ///
    /// # Example
    ///
    /// ```
    /// match exp.tick_attack(ips, &flag_store).await {
    ///     Ok(_) => (),
    ///     Err(e) => return handle_docker_errors(e),
    /// }
    /// ```
    pub async fn tick_attack(
        self,
        ips: Vec<String>,
        flag_store: String,
    ) -> Result<(), DockerErrors> {
        let mut tasks = Vec::new();
        let pool_size = self.containerpool.size as usize;

        // Split the workload over the available containers
        for t in 0..pool_size {
            let start = t * ips.len() / pool_size;
            let end: usize = (t + 1) * ips.len() / pool_size;

            let task_ips = ips[start..end].to_vec();

            task_ips.iter().for_each(|ip| {
                let container = self.containerpool.containers[t].clone();
                let ip = ip.clone();
                let flag_store = flag_store.clone();

                tasks.push(tokio::spawn(async move {
                    let output = match container.run(ip, &flag_store).await {
                        Ok(output) => output,
                        Err(e) => return Err(e),
                    };

                    Ok(output.flags())
                }));
            });
        }

        futures::future::join_all(tasks)
            .await
            .iter()
            .for_each(|o| match o.as_ref() {
                Ok(flags_res) => match flags_res {
                    Ok(flags) => println!("{}", flags.join("\n")), // TODO: send to flag submitter
                    Err(e) => return handle_docker_errors(e.clone()),
                },
                Err(e) => return println!("Join error:\n\t{:?}", e),
            });

        Ok(())
    }
}
