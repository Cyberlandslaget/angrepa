use futures::StreamExt;
use shiplift::tty::TtyChunk;
use shiplift::{BuildOptions, ContainerOptions, Docker, LogsOptions};
use std::str::from_utf8;

use super::{DockerErrors, OutputStd};

const DATA_PATH: &str = concat!(env!("CARGO_MANIFEST_DIR"), "/data");

#[derive(Debug, Clone)]
pub struct Exploit {
    name: String,
    tag: String,
}

impl Exploit {
    pub async fn init(name: &str) -> Result<Exploit, DockerErrors> {
        let tag = match image_build(&name).await {
            Ok(tag) => tag,
            Err(e) => return Err(e),
        };

        Ok(Exploit {
            name: name.to_string(),
            tag: tag,
        })
    }

    pub async fn run(self, ip: String, flag_store: String) 
    ->  Result<OutputStd, DockerErrors>
    {
        println!("Thread started for ip: {}", ip);
        let docker = Docker::new();
        let ip_env = ["IP", ip.as_str()].join("=");
        let flag_store_env = ["FLAG_STORE", flag_store.as_str()].join("=");
        let options = ContainerOptions::builder(&self.tag)
            .env(vec![ip_env.as_str(), flag_store_env.as_str()])
            .attach_stdout(true)
            .attach_stderr(true)
            .network_mode("host")
            .build();

        let info = match docker
        .containers()
        .create(&options)
        .await
        {
            Ok(info) => info,
            Err(e) => {
                return Err(DockerErrors::ContainerCreate(format!(
                    "Failed to create container for exploit: \"{}\"\n\t{:?}",
                    &self.tag, e
                )))
            }
        };
    
        let container = docker.containers().get(&info.id);
        
        println!("Starting container for ip: {}", ip);
        if let Err(e) = container.start().await {
            return Err(DockerErrors::ContainerStart(format!(
                "Failed to start container for exploit: \"{}\"\n\t{:?}",
                &self.tag, e
            )));
        }

        // Wait until container is finished
        
        let _ = container.wait().await;
        println!("Container finished for ip: {}", ip);
        let mut logs_stream = 
        container.logs(&LogsOptions::builder().stdout(true).stderr(true).build());

        let mut stdout_vec: Vec<Vec<u8>> = vec![];
        let mut stderr_vec: Vec<Vec<u8>> = vec![];
        
        while let Some(log_result) = logs_stream.next().await {
            match log_result {
                Ok(chunk) => match chunk{
                    TtyChunk::StdOut(bytes) => stdout_vec.push(bytes),
                    TtyChunk::StdErr(bytes) => stderr_vec.push(bytes),
                    TtyChunk::StdIn(_) => unreachable!(),
                },
                Err(e) => {
                    return Err(DockerErrors::ExecuteError(format!(
                        "Failed to execute container with id \"{}\"\n\t{:?}",
                        &self.tag[..12],
                        e
                    )))
                }
            }
        }
        let stdout_vec = stdout_vec.into_iter().flatten().collect::<Vec<u8>>();
        let stderr_vec = stderr_vec.into_iter().flatten().collect::<Vec<u8>>();
    
        let stdout = match from_utf8(&stdout_vec) {
            Ok(stdout) => stdout,
            Err(e) => {
                return Err(DockerErrors::OutputParse(format!(
                    "Failed to convert utf_8 of container exec with id \"{}\"\n\t{:?}",
                    &self.tag[..12],
                    e
                )))
            }
        };
    
        let stderr = match from_utf8(&stderr_vec) {
            Ok(stderr) => stderr,
            Err(e) => {
                return Err(DockerErrors::OutputParse(format!(
                    "Failed to convert utf_8 of container exec with id \"{}\"\n\t{:?}",
                    &self.tag[..12],
                    e
                )))
            }
        };
    
        Ok(OutputStd {
            stdout: String::from(stdout),
            stderr: String::from(stderr),
        })
    }
}

async fn image_build(exploit_id: &str) -> Result<String, DockerErrors> {
    let docker = Docker::new();

    let tag = format!("angrapa/exploit-{exploit_id}");
    let exploit_path = format!("{DATA_PATH}/exploits/{exploit_id}");

    let options = BuildOptions::builder(exploit_path).tag(&tag).build();

    let mut stream = docker.images().build(&options);
    while let Some(build_result) = stream.next().await {
        match build_result {
            // Ok(output) => println!("{:?}", output), // TODO? print this if theres some sort of debug mode enabled?
            Ok(_) => (),
            Err(e) => {
                return Err(DockerErrors::Build(format!(
                    "Failed to build image for exploit: \"{exploit_id}\"\n\t{:?}",
                    e,
                )))
            }
        }
    }

    Ok(tag)
}
