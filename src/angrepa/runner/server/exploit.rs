use axum::{
    body::{Bytes, StreamBody},
    extract::{Path, State},
    http::{header, StatusCode},
    response::{IntoResponse, Response},
    routing::{get, post},
    Json, Router,
};
use axum_typed_multipart::{FieldData, TryFromMultipart, TypedMultipart};
use serde_json::{json, Value};
use std::sync::Arc;
use tokio_util::io::ReaderStream;

use angrepa::db::Db;
use angrepa::models::ExploitInserter;

use crate::runner::exploit::docker::DockerInstance;

use super::AppState;

#[derive(TryFromMultipart)]
struct RequestData {
    tar: FieldData<Bytes>,
    config: FieldData<Bytes>,
}

// POST /exploit/upload
async fn upload(
    State(state): State<Arc<AppState>>,
    TypedMultipart(RequestData { tar, config }): TypedMultipart<RequestData>,
) -> (StatusCode, Json<Value>) {
    let mut conn = state.db.get().unwrap();
    let mut db = Db::new(&mut conn);

    fn default_pool_size() -> usize {
        1
    }

    #[derive(serde::Deserialize)]
    struct JsonConfig {
        name: String,
        service: String,
        blacklist: Vec<String>,
        // optional
        #[serde(default = "default_pool_size")]
        pool_size: usize,
    }

    // read data
    let json_config = match serde_json::from_slice(&config.contents) {
        Ok(json_config) => json_config,
        Err(e) => {
            return (
                StatusCode::BAD_REQUEST,
                json!({ "status": "error", "message": format!("Failed to parse config: {:?}", e) })
                    .into(),
            );
        }
    };

    let JsonConfig {
        name,
        service,
        blacklist,
        pool_size,
    } = json_config;

    // make sure the service exists
    let exists = match db.service_exists(&service) {
        Ok(exists) => exists,
        Err(e) => {
            return (
                StatusCode::INTERNAL_SERVER_ERROR,
                json!({ "status": "error", "message": format!("Failed to check if service exists: {:?}", e) })
                    .into(),
            )
        }
    };

    if !exists {
        return (
            StatusCode::NOT_FOUND,
            json!({ "status": "error", "message": "Service not found" }).into(),
        );
    }

    // build the exploit
    let docker = match DockerInstance::new() {
        Ok(docker) => docker,
        Err(e) => {
            return (
                StatusCode::INTERNAL_SERVER_ERROR,
                json!({ "status": "error", "message": format!("Failed to connect to docker: {:?}", e) })
                    .into(),
            );
        }
    };

    let exploit = docker.new_exploit(&tar.contents).await;

    let (exploit, build_log) = match exploit {
        Ok(exploit) => exploit,
        Err(e) => {
            return (
                StatusCode::INTERNAL_SERVER_ERROR,
                json!({ "status": "error", "message": format!("Failed to build exploit: {:?}", e) })
                    .into(),
            );
        }
    };

    let exploit = match exploit.spawn(pool_size).await {
        Ok(pool) => pool,
        Err(e) => {
            return (
                StatusCode::INTERNAL_SERVER_ERROR,
                json!({ "status": "error", "message": format!("Failed to spawn exploit: {:?}", e) })
                    .into(),
            );
        }
    };

    let expl = match db.add_exploit(&ExploitInserter {
        name,
        service,
        blacklist,
        pool_size: pool_size as i32,
        docker_image: exploit.image,
        docker_containers: exploit.pool.containers(),
        enabled: false,
    }) {
        Ok(expl) => expl,
        Err(e) => {
            return (
                StatusCode::INTERNAL_SERVER_ERROR,
                json!({ "status": "error", "message": format!("Failed to add exploit to DB: {:?}", e) })
                    .into(),
            );
        }
    };

    // save to file
    if let Err(e) = std::fs::write(format!("./data/exploits/{}", expl.id), &tar.contents) {
        return (
            StatusCode::INTERNAL_SERVER_ERROR,
            json!({ "status": "error", "message": format!("Failed to save exploit: {:?}", e) })
                .into(),
        );
    }

    (
        StatusCode::OK,
        json!({ "status": "ok", "id": expl.id, "build_log": build_log }).into(),
    )
}

// GET /exploit/download/:id
async fn download(Path(id): Path<i32>) -> Response {
    let file = match tokio::fs::File::open(format!("./data/exploits/{id}")).await {
        Ok(file) => file,
        Err(err) => {
            return (StatusCode::NOT_FOUND, format!("File not found: {}", err)).into_response()
        }
    };

    let body = StreamBody::new(ReaderStream::new(file));

    Response::builder()
        .header(header::CONTENT_TYPE, "application/x-tar")
        .header(
            header::CONTENT_DISPOSITION,
            format!("attachment; filename=\"{id}.tar\""),
        )
        .body(body)
        .unwrap()
        .into_response()
}

// GET|POST /exploit/start/:id
async fn start(
    State(state): State<Arc<AppState>>,
    Path(id): Path<i32>,
) -> (StatusCode, Json<Value>) {
    let conn = &mut state.db.get().unwrap();
    let mut db = Db::new(conn);

    match db.start_exploit(id) {
        Ok(_) => (StatusCode::OK, json!({ "status": "ok"}).into()),
        Err(e) => (
            StatusCode::INTERNAL_SERVER_ERROR,
            json!({ "status": "error", "message": format!("Failed to start exploit: {:?}", e) })
                .into(),
        ),
    }
}

// GET|POST /exploit/stop/:id
async fn stop(
    State(state): State<Arc<AppState>>,
    Path(id): Path<i32>,
) -> (StatusCode, Json<Value>) {
    let mut conn = state.db.get().unwrap();
    let mut db = Db::new(&mut conn);

    match db.stop_exploit(id) {
        Ok(_) => (StatusCode::OK, json!({ "status": "ok"}).into()),
        Err(e) => (
            StatusCode::INTERNAL_SERVER_ERROR,
            json!({ "status": "error", "message": format!("Failed to stop exploit: {:?}", e) })
                .into(),
        ),
    }
}

// /exploit/
pub fn router(state: Arc<AppState>) -> Router {
    Router::new()
        .route("/upload", post(upload))
        .route("/download/:id", get(download))
        .route("/start/:id", get(start).post(start))
        .route("/stop/:id", get(stop).post(stop))
        .with_state(state)
}
