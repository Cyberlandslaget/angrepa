use super::AppState;
use crate::runner::exploit::{docker::DockerInstance, Exploit};
use angrepa::db::Db;
use angrepa::models::ExploitInserter;
use axum::{
    body::{Bytes, StreamBody},
    extract,
    extract::{Path, State},
    http::{header, StatusCode},
    response::{IntoResponse, Response},
    routing::{get, post},
    Json, Router,
};
use axum_typed_multipart::{FieldData, TryFromMultipart, TypedMultipart};
use serde_json::{json, Value};
use std::sync::Arc;
use tokio_util::io::ReaderStream;
use tracing::debug;

#[derive(TryFromMultipart)]
struct RequestData {
    tar: FieldData<Bytes>,
    config: FieldData<Bytes>,
}

fn default_pool_size() -> usize {
    1
}

#[derive(serde::Deserialize)]
struct JsonConfig {
    name: String,
    service: String,
    blacklist: Vec<String>,
    // optional
    #[serde(default = "default_pool_size")]
    pool_size: usize,
    #[serde(default)]
    skip_test: bool,
}

// POST /exploit/upload
async fn upload(
    State(state): State<Arc<AppState>>,
    TypedMultipart(RequestData { tar, config }): TypedMultipart<RequestData>,
) -> (StatusCode, Json<Value>) {
    let mut conn = state.db.get().unwrap();
    let mut db = Db::new(&mut conn);

    // read data
    let json_config = match serde_json::from_slice(&config.contents) {
        Ok(json_config) => json_config,
        Err(e) => {
            return (
                StatusCode::BAD_REQUEST,
                json!({ "status": "error", "message": format!("Failed to parse config: {:?}", e) })
                    .into(),
            );
        }
    };

    let JsonConfig {
        name,
        service,
        blacklist,
        pool_size,
        skip_test,
    } = json_config;

    // make sure the service exists
    let exists = match db.service_exists(&service) {
        Ok(exists) => exists,
        Err(e) => {
            return (
                StatusCode::INTERNAL_SERVER_ERROR,
                json!({ "status": "error", "message": format!("Failed to check if service exists: {:?}", e) })
                    .into(),
            )
        }
    };

    if !exists {
        return (
            StatusCode::NOT_FOUND,
            json!({ "status": "error", "message": "Service not found" }).into(),
        );
    }

    // build the exploit
    let docker = match DockerInstance::new() {
        Ok(docker) => docker,
        Err(e) => {
            return (
                StatusCode::INTERNAL_SERVER_ERROR,
                json!({ "status": "error", "message": format!("Failed to connect to docker: {:?}", e) })
                    .into(),
            );
        }
    };

    let exploit = docker.new_exploit(&tar.contents).await;

    let (exploit, build_log) = match exploit {
        Ok(exploit) => exploit,
        Err(e) => {
            return (
                StatusCode::INTERNAL_SERVER_ERROR,
                json!({ "status": "error", "message": format!("Failed to build exploit: {:?}", e) })
                    .into(),
            );
        }
    };

    // spawn the container pool
    let mut exploit = match exploit.spawn(pool_size).await {
        Ok(pool) => pool,
        Err(e) => {
            return (
                StatusCode::INTERNAL_SERVER_ERROR,
                json!({ "status": "error", "message": format!("Failed to spawn exploit: {:?}", e) })
                    .into(),
            );
        }
    };

    // test against the NOP team
    let test_msg = if let Some(ref nop) = state.config.common.nop {
        if skip_test {
            "skipped as requested"
        } else {
            debug!("Testing exploit before adding to db");

            let target = match db.get_latest_nop_target(nop) {
                Ok(t) => t,
                Err(e) => {
                    return (
                        StatusCode::INTERNAL_SERVER_ERROR,
                        json!({ "status": "error", "message": format!("Failed getting latest nop target: {:?}", e) }).into(),
                    );
                }
            };

            if let Some(target) = target {
                let run = exploit.run(nop.to_owned(), target.flag_id).await;

                let run = match run {
                    Ok(r) => r,
                    Err(e) => {
                        return (
                            StatusCode::INTERNAL_SERVER_ERROR,
                            json!({ "status": "error", "message": format!("Failed to run exploit: {:?}", e) }).into(),
                        );
                    }
                };

                let logs = match run.await {
                    Ok(l) => l,
                    Err(e) => {
                        return (
                            StatusCode::INTERNAL_SERVER_ERROR,
                            json!({ "status": "error", "message": format!("Failed to get logs: {:?}", e) }).into(),
                        );
                    }
                };

                if logs.exit_code != 0 {
                    return (
                        StatusCode::INTERNAL_SERVER_ERROR,
                        json!({ "status": "error", "message": format!("Test against NOP team failed with exit code {}. Force with config {{...,skip_test: true}}. stdout: {}", logs.exit_code, logs.output) }).into(),
                    );
                }

                // todo (?) check if it printed a flag

                "great success"
            } else {
                "skipped due to no suitable target"
            }
        }
    } else {
        "skipped due to missing nop team"
    };

    let expl = match db.add_exploit(&ExploitInserter {
        name,
        service,
        blacklist,
        pool_size: pool_size as i32,
        docker_image: exploit.image,
        docker_containers: exploit.pool.containers(),
        enabled: false,
    }) {
        Ok(expl) => expl,
        Err(e) => {
            return (
                StatusCode::INTERNAL_SERVER_ERROR,
                json!({ "status": "error", "message": format!("Failed to add exploit to DB: {:?}", e) })
                    .into(),
            );
        }
    };

    // save to file
    if let Err(e) = std::fs::write(format!("./data/exploits/{}", expl.id), &tar.contents) {
        return (
            StatusCode::INTERNAL_SERVER_ERROR,
            json!({ "status": "error", "message": format!("Failed to save exploit: {:?}", e) })
                .into(),
        );
    }

    (
        StatusCode::OK,
        json!({ "status": "ok", "id": expl.id, "build_log": build_log, "test_msg": test_msg })
            .into(),
    )
}

// POST /exploit/edit/:id
async fn exploit_edit_config(
    State(state): State<Arc<AppState>>,
    Path(id): Path<i32>,
    extract::Json(config): extract::Json<JsonConfig>,
) -> (StatusCode, Json<Value>) {
    let mut conn = state.db.get().unwrap();
    let mut db = Db::new(&mut conn);

    match db.exploit_edit_config(id, config.name, config.blacklist, config.pool_size as i32) {
        Ok(()) => (StatusCode::OK, json!({ "status": "ok"}).into()),
        Err(e) => (
            StatusCode::INTERNAL_SERVER_ERROR,
            json!({ "status": "error", "message": format!("Failed to update config: {:?}", e) })
                .into(),
        ),
    }
}

// GET /exploit/download/:id
async fn download(Path(id): Path<i32>) -> Response {
    let file = match tokio::fs::File::open(format!("./data/exploits/{id}")).await {
        Ok(file) => file,
        Err(err) => {
            return (StatusCode::NOT_FOUND, format!("File not found: {}", err)).into_response()
        }
    };

    let body = StreamBody::new(ReaderStream::new(file));

    Response::builder()
        .header(header::CONTENT_TYPE, "application/x-tar")
        .header(
            header::CONTENT_DISPOSITION,
            format!("attachment; filename=\"{id}.tar\""),
        )
        .body(body)
        .unwrap()
        .into_response()
}

// GET|POST /exploit/start/:id
async fn start(
    State(state): State<Arc<AppState>>,
    Path(id): Path<i32>,
) -> (StatusCode, Json<Value>) {
    let conn = &mut state.db.get().unwrap();
    let mut db = Db::new(conn);

    match db.start_exploit(id) {
        Ok(_) => (StatusCode::OK, json!({ "status": "ok"}).into()),
        Err(e) => (
            StatusCode::INTERNAL_SERVER_ERROR,
            json!({ "status": "error", "message": format!("Failed to start exploit: {:?}", e) })
                .into(),
        ),
    }
}

// GET|POST /exploit/stop/:id
async fn stop(
    State(state): State<Arc<AppState>>,
    Path(id): Path<i32>,
) -> (StatusCode, Json<Value>) {
    let mut conn = state.db.get().unwrap();
    let mut db = Db::new(&mut conn);

    match db.stop_exploit(id) {
        Ok(_) => (StatusCode::OK, json!({ "status": "ok"}).into()),
        Err(e) => (
            StatusCode::INTERNAL_SERVER_ERROR,
            json!({ "status": "error", "message": format!("Failed to stop exploit: {:?}", e) })
                .into(),
        ),
    }
}

// /exploit/
pub fn router(state: Arc<AppState>) -> Router {
    Router::new()
        .route("/upload", post(upload))
        .route("/edit/:id", post(exploit_edit_config))
        .route("/download/:id", get(download))
        .route("/start/:id", get(start).post(start))
        .route("/stop/:id", get(stop).post(stop))
        .with_state(state)
}
